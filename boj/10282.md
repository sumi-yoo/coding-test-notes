# BOJ 10282 - 해킹

## 문제 링크
[https://www.acmicpc.net/problem/10282](https://www.acmicpc.net/problem/10282)

---

## 문제 요약
컴퓨터들이 네트워크로 연결되어 있고, 한 컴퓨터가 해킹되면 연결된 다른 컴퓨터로 바이러스가 전파된다.  
전파에는 시간이 걸리며, 의존성 관계가 주어진다.  
특정 컴퓨터가 해킹되면 감염되는 컴퓨터 수와 그 중 가장 늦게 감염되는 시간(초)을 구하는 문제.

## 핵심 아이디어
- 의존성 관계: `a b s` → b가 해킹되면 s초 후에 a도 해킹됨  
- 시작 컴퓨터에서 **최단 시간**으로 다른 컴퓨터가 감염되는 시간을 구하면 된다.
- 전형적인 **다익스트라 알고리즘** 문제.
- `graph[b]`에 `(a, s)`를 저장 (b에서 a로 가는 간선)
- 다익스트라로 최단 감염 시간 배열을 구한 뒤:
  - 감염된 컴퓨터 수 = `INF`가 아닌 정점의 개수
  - 최종 시간 = `dist[]` 중 최대값


## 자바 코드
```java
import java.io.*;
import java.util.*;

public class Main {

    static final int INF = 1_000_000_000;
    static int n;
    static List<Node>[] graph;

    static class Node implements Comparable<Node> {
        int idx, time;

        Node(int idx, int time) {
            this.idx = idx;
            this.time = time;
        }

        @Override
        public int compareTo(Node o) {
            return 0;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int T = Integer.parseInt(br.readLine());

        for (int t = 0; t < T; t++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            n = Integer.parseInt(st.nextToken());
            int d = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            graph = new ArrayList[n + 1];
            for (int i = 1; i <= n; i++) {
                graph[i] = new ArrayList<>();
            }

            for (int i = 0; i < d; i++) {
                st = new StringTokenizer(br.readLine());
                int a = Integer.parseInt(st.nextToken());
                int b = Integer.parseInt(st.nextToken());
                int s = Integer.parseInt(st.nextToken());

                graph[b].add(new Node(a, s));
            }

            int[] dist = dijkstra(c);
            int maxTime = 0;
            int cnt = 0;
            for (int i = 1; i <= n; i++) {
                if (dist[i] < INF) {
                    cnt++;
                    maxTime = Math.max(maxTime, dist[i]);
                }
            }

            bw.write(cnt + " " + maxTime + "\n");
        }

        bw.flush();
        bw.close();
        br.close();
    }

    static int[] dijkstra(int start) {
        int[] dist = new int[n + 1];
        Arrays.fill(dist, INF);
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            if (dist[now.idx] < now.time) continue;

            for (Node next: graph[now.idx]) {
                int nextTime = next.time + now.time;
                if (dist[next.idx] > nextTime) {
                    dist[next.idx] = nextTime;
                    pq.offer(new Node(next.idx, nextTime));
                }
            }
        }

        return dist;
    }
}
```