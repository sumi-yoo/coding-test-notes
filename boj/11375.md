# BOJ 11375 - 열혈강호

## 문제 링크
[https://www.acmicpc.net/problem/11375](https://www.acmicpc.net/problem/11375)

## 문제 요약
- 직원 N명, 일 M개.
- 각 직원은 자신이 할 수 있는 일들의 목록을 가짐.
- 제약:
  - 한 직원은 최대 1개의 일만 담당 가능.
  - 한 일은 직원 1명에게만 배정 가능.
- 목표: 배정 가능한 일의 최대 개수(= 최대 매칭 크기)를 구하라.

## 핵심 아이디어
- 전형적인 **이분 그래프 최대 매칭** 문제.
  - 왼쪽 집합: 직원(1..N), 오른쪽 집합: 일(1..M)
  - 간선: 직원 i가 할 수 있는 일 j
- **DFS 기반 증가 경로(augmenting path)** 탐색으로 매칭을 1씩 늘려감.
  - 어떤 직원이 원하는 일이 이미 배정되어 있으면 그 일을 맡은 직원을 다른 일로 재배치할 수 있는지 DFS로 시도.
- 매 직원마다 visited(일 방문 체크) 배열을 새로 초기화.

## 알고리즘 흐름
1. 인접 리스트 wants[i]에 직원 i가 할 수 있는 일들을 저장.
2. matchJob[j] = 일 j에 배정된 직원 번호(없으면 0).
3. 모든 직원 i에 대해:
   - visited[1..M] = false 초기화
   - dfs(i)가 true면 정답++.
4. 정답 출력.

## 시간 복잡도
- DFS 기반 이분 매칭: 대략 O(N × M) (간선 수에 비례)
- N, M ≤ 1000 범위에서 충분히 통과.

## 구현 팁 / 주의
- 입력 형식: 각 직원 i 줄에 `k t1 t2 ... tk` (할 수 있는 일의 개수 k와 번호들)
- 매 직원마다 visited[]는 반드시 초기화해야 중복/무한 탐색을 방지.
- matchJob은 “일 기준” 매칭 테이블로 두면 구현이 깔끔함.

## 전체 코드 (Java)
```java
import java.io.*;
import java.util.*;

public class Main {
    static int N, M;
    static List<Integer>[] wants; // wants[worker] = 이 직원이 할 수 있는 일 목록
    static int[] matchJob;        // matchJob[job] = 이 일을 맡은 직원 (없으면 0)
    static boolean[] visited;     // DFS에서 일 방문 체크 (매 직원마다 초기화)

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        wants = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) wants[i] = new ArrayList<>();

        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            int k = Integer.parseInt(st.nextToken());
            for (int t = 0; t < k; t++) {
                int job = Integer.parseInt(st.nextToken());
                wants[i].add(job);
            }
        }

        matchJob = new int[M + 1];
        int answer = 0;

        for (int worker = 1; worker <= N; worker++) {
            visited = new boolean[M + 1];
            if (dfs(worker)) answer++;
        }

        System.out.println(answer);
    }

    // worker를 어떤 일에든 배정할 수 있으면 true
    static boolean dfs(int worker) {
        for (int job : wants[worker]) {
            if (visited[job]) continue;
            visited[job] = true;

            // 이 일이 비어 있거나, 현재 이 일을 맡은 직원을 다른 일로 옮길 수 있으면 점유
            if (matchJob[job] == 0 || dfs(matchJob[job])) {
                matchJob[job] = worker;
                return true;
            }
        }
        return false;
    }
}
```