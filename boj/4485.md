# BOJ 4485 - 녹색 옷 입은 애가 젤다지?

## 문제 링크
[https://www.acmicpc.net/problem/4485](https://www.acmicpc.net/problem/4485)

---

## 🧩 문제 설명

N x N 크기의 동굴이 주어진다. 각 칸마다 도둑 루피를 잃게 되는 비용이 주어지며, `(0,0)`에서 출발해 `(N-1,N-1)`로 가는 최소 비용을 구하는 문제이다.

- 상하좌우 네 방향으로 이동할 수 있음
- 도착지에 도달할 때까지 잃는 최소 루피의 합을 출력

---

## 📌 입력

- 테스트 케이스 여러 개
- 각 케이스의 첫 줄: 정수 N (2 ≤ N ≤ 125)
- 다음 N줄: N개의 정수 (각 칸에서 잃는 도둑 루피 양, 0~9)
- 입력의 끝은 N = 0

---

## 📤 출력

- 각 테스트 케이스마다 다음 형식으로 출력  
  `Problem i: 최소비용`

---

## ✅ 아이디어

- **다익스트라 알고리즘**을 2차원 배열에 적용
- 각 칸을 정점, 상하좌우 인접 칸을 간선으로 간주
- 시작점 `(0,0)`에서 비용 누적하며 최소 경로 탐색

---

## 📘 알고리즘

- 시작 지점 `(0, 0)`의 비용부터 시작
- `dist[x][y]`에 해당 좌표까지의 최소 비용 저장
- 우선순위 큐(`PriorityQueue`)로 매번 비용이 가장 작은 노드를 우선 처리
- 다음 좌표로 이동할 때 `현재 비용 + map[nx][ny]`로 갱신
- 도착 지점 `(N-1, N-1)`에 도달하면 해당 비용 리턴

---

## 💻 코드 (Java)

```java
import java.io.*;
import java.util.*;

public class Main {

    static final int INF = 1_000_000_000;
    static int N;
    static int[][] map, dist;
    static boolean[][] isVisited;
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    static class Node implements Comparable<Node> {
        int x, y, cost;

        Node(int x, int y, int cost) {
            this.x = x;
            this.y = y;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int count = 0;
        while (true) {
            N = Integer.parseInt(br.readLine());
            if (N == 0) break;

            map = new int[N][N];
            dist = new int[N][N];
            isVisited = new boolean[N][N];
            for (int i = 0; i < N; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                for (int j = 0; j < N; j++) {
                    map[i][j] = Integer.parseInt(st.nextToken());
                    dist[i][j] = INF;
                }
            }

            dijkstra();

            String result = String.format("Problem %d: %d\n", ++count, dist[N - 1][N - 1]);
            bw.write(result);

        }

        bw.flush();
        bw.close();
        br.close();
    }

    static void dijkstra() {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(0, 0, map[0][0]));
        dist[0][0] = map[0][0];

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            if (isVisited[now.x][now.y]) continue;
            isVisited[now.x][now.y] = true;

            for (int i = 0; i < 4; i++) {
                int nx = dx[i] + now.x;
                int ny = dy[i] + now.y;
                if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;

                int nextCost = now.cost + map[nx][ny];
                if (nextCost < dist[nx][ny]) {
                    dist[nx][ny] = nextCost;
                    pq.offer(new Node(nx, ny, nextCost));
                }
            }
        }
    }
}
```