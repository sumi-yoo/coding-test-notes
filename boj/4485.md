# BOJ 4485 - ë…¹ìƒ‰ ì˜· ì…ì€ ì• ê°€ ì ¤ë‹¤ì§€?

## ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/4485](https://www.acmicpc.net/problem/4485)

---

## ğŸ§© ë¬¸ì œ ì„¤ëª…

N x N í¬ê¸°ì˜ ë™êµ´ì´ ì£¼ì–´ì§„ë‹¤. ê° ì¹¸ë§ˆë‹¤ ë„ë‘‘ ë£¨í”¼ë¥¼ ìƒê²Œ ë˜ëŠ” ë¹„ìš©ì´ ì£¼ì–´ì§€ë©°, `(0,0)`ì—ì„œ ì¶œë°œí•´ `(N-1,N-1)`ë¡œ ê°€ëŠ” ìµœì†Œ ë¹„ìš©ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

- ìƒí•˜ì¢Œìš° ë„¤ ë°©í–¥ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìŒ
- ë„ì°©ì§€ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ìƒëŠ” ìµœì†Œ ë£¨í”¼ì˜ í•©ì„ ì¶œë ¥

---

## ğŸ“Œ ì…ë ¥

- í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì—¬ëŸ¬ ê°œ
- ê° ì¼€ì´ìŠ¤ì˜ ì²« ì¤„: ì •ìˆ˜ N (2 â‰¤ N â‰¤ 125)
- ë‹¤ìŒ Nì¤„: Nê°œì˜ ì •ìˆ˜ (ê° ì¹¸ì—ì„œ ìƒëŠ” ë„ë‘‘ ë£¨í”¼ ì–‘, 0~9)
- ì…ë ¥ì˜ ëì€ N = 0

---

## ğŸ“¤ ì¶œë ¥

- ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì¶œë ¥  
  `Problem i: ìµœì†Œë¹„ìš©`

---

## âœ… ì•„ì´ë””ì–´

- **ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜**ì„ 2ì°¨ì› ë°°ì—´ì— ì ìš©
- ê° ì¹¸ì„ ì •ì , ìƒí•˜ì¢Œìš° ì¸ì ‘ ì¹¸ì„ ê°„ì„ ìœ¼ë¡œ ê°„ì£¼
- ì‹œì‘ì  `(0,0)`ì—ì„œ ë¹„ìš© ëˆ„ì í•˜ë©° ìµœì†Œ ê²½ë¡œ íƒìƒ‰

---

## ğŸ“˜ ì•Œê³ ë¦¬ì¦˜

- ì‹œì‘ ì§€ì  `(0, 0)`ì˜ ë¹„ìš©ë¶€í„° ì‹œì‘
- `dist[x][y]`ì— í•´ë‹¹ ì¢Œí‘œê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš© ì €ì¥
- ìš°ì„ ìˆœìœ„ í(`PriorityQueue`)ë¡œ ë§¤ë²ˆ ë¹„ìš©ì´ ê°€ì¥ ì‘ì€ ë…¸ë“œë¥¼ ìš°ì„  ì²˜ë¦¬
- ë‹¤ìŒ ì¢Œí‘œë¡œ ì´ë™í•  ë•Œ `í˜„ì¬ ë¹„ìš© + map[nx][ny]`ë¡œ ê°±ì‹ 
- ë„ì°© ì§€ì  `(N-1, N-1)`ì— ë„ë‹¬í•˜ë©´ í•´ë‹¹ ë¹„ìš© ë¦¬í„´

---

## ğŸ’» ì½”ë“œ (Java)

```java
import java.io.*;
import java.util.*;

public class Main {

    static final int INF = 1_000_000_000;
    static int N;
    static int[][] map, dist;
    static boolean[][] isVisited;
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    static class Node implements Comparable<Node> {
        int x, y, cost;

        Node(int x, int y, int cost) {
            this.x = x;
            this.y = y;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int count = 0;
        while (true) {
            N = Integer.parseInt(br.readLine());
            if (N == 0) break;

            map = new int[N][N];
            dist = new int[N][N];
            isVisited = new boolean[N][N];
            for (int i = 0; i < N; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                for (int j = 0; j < N; j++) {
                    map[i][j] = Integer.parseInt(st.nextToken());
                    dist[i][j] = INF;
                }
            }

            dijkstra();

            String result = String.format("Problem %d: %d\n", ++count, dist[N - 1][N - 1]);
            bw.write(result);

        }

        bw.flush();
        bw.close();
        br.close();
    }

    static void dijkstra() {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(0, 0, map[0][0]));
        dist[0][0] = map[0][0];

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            if (isVisited[now.x][now.y]) continue;
            isVisited[now.x][now.y] = true;

            for (int i = 0; i < 4; i++) {
                int nx = dx[i] + now.x;
                int ny = dy[i] + now.y;
                if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;

                int nextCost = now.cost + map[nx][ny];
                if (nextCost < dist[nx][ny]) {
                    dist[nx][ny] = nextCost;
                    pq.offer(new Node(nx, ny, nextCost));
                }
            }
        }
    }
}
```