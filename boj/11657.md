# BOJ 11657 - 타임머신

🔗 문제 링크: [https://www.acmicpc.net/problem/11657](https://www.acmicpc.net/problem/11657)

---

## 📝 문제 설명

- 도시 N개와 M개의 버스 노선이 있다.  
- 각 버스 노선은 **시작 도시, 도착 도시, 걸리는 시간**이 주어지며, 음수 시간도 존재할 수 있다.
- **1번 도시에서 출발하여 나머지 모든 도시로 가는 최단 시간을 구하라.**
- **만약 음수 사이클**이 존재하면 `-1`을 출력한다.

---

## ✅ 문제 핵심 포인트

- **가중치에 음수가 포함**되어 있으므로 다익스트라 사용 불가능.
- 최단 경로를 구하면서 **음수 사이클 탐지**가 가능한 **벨만-포드 알고리즘**을 사용해야 한다.

---

## ⚙️ 알고리즘 풀이

1. **벨만-포드 알고리즘**을 통해 1번 도시에서 출발하는 최단 거리 배열을 구한다.
2. 음수 사이클 탐지를 위해 **N번째 반복에서 거리 갱신이 발생하는지** 확인한다.
3. 거리 배열 출력 시, 도달할 수 없는 도시는 `-1`로 표시한다.

---

## ⏱️ 시간 복잡도

- 벨만-포드 알고리즘: `O(N * M)`  
  → N ≤ 500, M ≤ 6,000 이므로 충분히 가능

---

## 💡 주의할 점

- **음수 간선 존재 가능**
- **중복 간선 존재 가능**
- 거리 배열은 초기값 `INF`로 설정하되, 시작 정점만 `0`으로 설정

---

## 💻 Java 코드

```java
import java.io.*;
import java.util.*;

public class Main {

    static class Edge {
        int from, to, cost;

        Edge(int from, int to, int cost) {
            this.from = from;
            this.to = to;
            this.cost = cost;
        }
    }

    static final int INF = Integer.MAX_VALUE;
    static int N, M;
    static List<Edge> edges;
    static long[] dist;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        edges = new ArrayList<>();
        dist = new long[N + 1];
        Arrays.fill(dist, INF);
        dist[1] = 0; // 1번 도시에서 출발

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int from = Integer.parseInt(st.nextToken());
            int to = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            edges.add(new Edge(from, to, cost));
        }

        if (bellmanFord()) {
            bw.write("-1\n"); // 음수 사이클 존재
        } else {
            for (int i = 2; i <= N; i++) {
                if (dist[i] == INF) {
                    bw.write("-1\n");
                } else {
                    bw.write(dist[i] + "\n");
                }
            }
        }

        bw.flush();
        bw.close();
        br.close();
    }

    static boolean bellmanFord() {
        for (int i = 0; i < N; i++) {
            for (Edge edge : edges) {
                if (dist[edge.from] != INF && dist[edge.from] + edge.cost < dist[edge.to]) {
                    dist[edge.to] = dist[edge.from] + edge.cost;
                    if (i == N - 1) return true; // N번째 반복에서 갱신 → 음수 사이클
                }
            }
        }
        return false;
    }
}
```