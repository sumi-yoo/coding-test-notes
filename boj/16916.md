# BOJ 16916 - 부분 문자열

## 문제 링크
[https://www.acmicpc.net/problem/16916](https://www.acmicpc.net/problem/16916)

---

## 문제 요약
- 문자열 `S`와 `P`가 주어짐.
- 문자열 `P`가 문자열 `S`의 **부분 문자열**인지 판별.
- 포함되면 `1`, 아니면 `0` 출력.

---

## 단순한 접근
- 문자열 `S` 길이 최대 `1,000,000`, `P`도 최대 `1,000,000`.
- 단순하게 `S`의 모든 위치에서 `P`를 비교하면  
  시간 복잡도 `O(|S| × |P|)` → 최악의 경우 약 `10^12` 연산 → 시간 초과.

---

## 핵심 아이디어: KMP 알고리즘
- 문자열 검색 알고리즘 중 하나.
- **접두사(prefix)와 접미사(suffix)의 일치 길이**를 이용해  
  불필요한 비교를 건너뛰는 방식.
- 시간 복잡도: `O(|S| + |P|)` → 200만 정도 연산이므로 충분히 가능.

---

## KMP 동작 원리

### 1. 실패 함수 (pi 배열)
- `pi[i]` = `P[0..i]` 문자열의 접두사이자 접미사인 부분 문자열의 최대 길이.
- 예: `P = "ababaca"`
  - pi 배열 = `[0, 0, 1, 2, 3, 0, 1]`

→ 이 정보를 통해, 매칭 도중 불일치가 발생하면  
이미 검사한 접두사 정보를 활용해서 건너뛰기 가능.

---

### 2. 문자열 검색
- `S`를 순회하며 `P`와 비교.
- 불일치가 발생하면, `pi` 배열 참고하여 이동.
- 일치하는 부분이 완성되면 매칭 성공 → 부분 문자열 존재.

---

## 알고리즘 흐름
1. 패턴 문자열 `P`로 **pi 배열** 생성.
2. 본문 문자열 `S`를 순회하면서:
   - 불일치 시 pi 배열 이용해 다음 비교 위치 결정.
   - 패턴 끝까지 매칭되면 부분 문자열 발견.
3. 발견 시 `1`, 끝까지 못 찾으면 `0`.

---

## 전체 코드 (Java)
```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String S = br.readLine();
        String P = br.readLine();
        
        if (kmp(S, P)) {
            System.out.println(1);
        } else {
            System.out.println(0);
        }
    }

    // KMP 메인 함수
    static boolean kmp(String S, String P) {
        int[] pi = getPi(P);
        int j = 0;

        for (int i = 0; i < S.length(); i++) {
            while (j > 0 && S.charAt(i) != P.charAt(j)) {
                j = pi[j - 1]; // 불일치 → pi 배열 참고해 점프
            }
            if (S.charAt(i) == P.charAt(j)) {
                if (j == P.length() - 1) {
                    return true; // 패턴 전체 일치
                } else {
                    j++;
                }
            }
        }
        return false;
    }

    // 실패 함수(pi 배열) 생성
    static int[] getPi(String P) {
        int[] pi = new int[P.length()];
        int j = 0;
        for (int i = 1; i < P.length(); i++) {
            while (j > 0 && P.charAt(i) != P.charAt(j)) {
                j = pi[j - 1];
            }
            if (P.charAt(i) == P.charAt(j)) {
                pi[i] = ++j;
            }
        }
        return pi;
    }
}

```