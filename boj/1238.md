# BOJ 1238 - 파티

🔗 문제 링크: [https://www.acmicpc.net/problem/1238](https://www.acmicpc.net/problem/1238)

---

## 문제 설명

- N개의 마을과 M개의 단방향 도로가 있다.
- 각 도로는 이동하는 데 걸리는 시간이 주어진다.
- 모든 학생들은 X 마을에서 열리는 파티에 참석하기 위해 출발지 마을에서 X 마을로 갔다가 다시 출발지로 돌아와야 한다.
- 각 학생이 출발지에서 X 마을로 가는 최단 시간과 X 마을에서 출발지로 돌아오는 최단 시간을 합친 값 중 최대값을 구하는 문제이다.

---

## 문제 핵심 아이디어

- 최단 경로 문제이므로 **다익스트라 알고리즘**을 사용한다.
- 모든 마을에서 X 마을까지 가는 최단 경로와 X 마을에서 모든 마을까지 가는 최단 경로를 구한다.
- 이를 위해 각 마을에서 X까지 가는 최단 경로를 구하기 위해 매번 다익스트라를 실행하고,
- X에서 모든 마을까지 가는 최단 경로는 한 번만 다익스트라를 실행한다.
- 최종적으로 각 마을 i에 대해 `distFromI[X] + distFromX[i]` 를 계산해 최대값을 구한다.

---

## 시간 복잡도

- 다익스트라를 최대 N번 실행하므로, 시간복잡도는 `O(N * E log V)` 이다.
- N과 E가 크지 않으면 충분히 통과 가능하다.

---

## 주요 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = 100_000_000;

    static int N;
    static List<Node>[] graph;

    static class Node implements Comparable<Node> {
        int idx, cost;

        Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int X = Integer.parseInt(st.nextToken());

        graph = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            graph[a].add(new Node(b, c));
        }

        int time = 0;
        for (int i = 1; i <= N; i++) {
            int[] distFromN = dijkstra(i);
            int[] distFromX = dijkstra(X);

            int dist = distFromN[X] + distFromX[i];
            time = Math.max(dist, time);
        }

        bw.write(time + "\n");

        bw.flush();
        bw.close();
        br.close();
    }

    static int[] dijkstra(int start) {
        int[] dist = new int[N + 1];
        for (int i = 1; i <= N; i++) {
            dist[i] = INF;
        }
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            for (Node next: graph[now.idx]) {
                int nextDist = next.cost + now.cost;
                if (nextDist < dist[next.idx]) {
                    dist[next.idx] = nextDist;
                    pq.offer(new Node(next.idx, nextDist));
                }
            }
        }

        return dist;
    }
}
```