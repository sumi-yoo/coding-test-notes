# BOJ 11438 - LCA 2

## ğŸ“Œ ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/11438](https://www.acmicpc.net/problem/11438)

---

## ğŸ“– ë¬¸ì œ ìš”ì•½
- ë£¨íŠ¸ê°€ 1ì¸ íŠ¸ë¦¬ê°€ ì£¼ì–´ì§.
- ë‘ ë…¸ë“œ `a`, `b`ê°€ ì£¼ì–´ì§ˆ ë•Œ, **ê°€ì¥ ê°€ê¹Œìš´ ê³µí†µ ì¡°ìƒ(LCA)**ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ.
- íŠ¸ë¦¬ì˜ í¬ê¸°: ìµœëŒ€ `100,000` ë…¸ë“œ, ì¿¼ë¦¬ ìµœëŒ€ `100,000`.

---

## ğŸ’¡ ì ‘ê·¼ ë°©ë²•
1. **íŠ¸ë¦¬ ì…ë ¥ ë°›ê¸°**
   - ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ íŠ¸ë¦¬ë¥¼ ì €ì¥.

2. **ë¶€ëª¨ì™€ ê¹Šì´ ê³„ì‚°**
   - DFS ë˜ëŠ” BFSë¥¼ í†µí•´ ê° ë…¸ë“œì˜ ë¶€ëª¨(`parent[node][0]`)ì™€ ê¹Šì´(`depth[node]`)ë¥¼ ê¸°ë¡.

3. **Binary Lifting**
   - parent[node][k] = nodeì˜ 2^k ë²ˆì§¸ ì¡°ìƒì„ ë¯¸ë¦¬ ê³„ì‚°
   - këŠ” 0ë¶€í„° log2(N)ê¹Œì§€

4. **LCA ì°¾ê¸°**
   - ë‘ ë…¸ë“œì˜ ê¹Šì´ë¥¼ ë§ì¶¤
   - 2^k ì í”„ë¥¼ ì´ìš©í•´ ë™ì‹œì— ìœ„ë¡œ ì˜¬ë¼ê°€ë©´ì„œ ê³µí†µ ì¡°ìƒ ì°¾ê¸°

---

## â±ï¸ ì‹œê°„ ë³µì¡ë„
- ì „ì²˜ë¦¬: O(N log N)
- ì¿¼ë¦¬: O(log N)
- N, Q â‰¤ 100,000 â†’ ì¶©ë¶„íˆ í†µê³¼

---

## ğŸ“ í’€ì´ ì½”ë“œ (Java)

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N, M;
    static ArrayList<Integer>[] tree;
    static int[][] parent;
    static int[] depth;
    static int MAX_LOG;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st;

        N = Integer.parseInt(br.readLine());
        MAX_LOG = (int)(Math.log(N) / Math.log(2)) + 1;

        tree = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) tree[i] = new ArrayList<>();

        for (int i = 0; i < N - 1; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            tree[a].add(b);
            tree[b].add(a);
        }

        parent = new int[N + 1][MAX_LOG];
        depth = new int[N + 1];

        // DFSë¡œ depthì™€ parent[?][0] ê³„ì‚°
        dfs(1, 0);

        // Binary Lifting ì „ì²˜ë¦¬
        for (int k = 1; k < MAX_LOG; k++) {
            for (int v = 1; v <= N; v++) {
                parent[v][k] = parent[parent[v][k - 1]][k - 1];
            }
        }

        M = Integer.parseInt(br.readLine());
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            bw.write(lca(a, b) + "\n");
        }

        br.close();
        bw.flush();
        bw.close();
    }

    static void dfs(int node, int par) {
        parent[node][0] = par;
        for (int next : tree[node]) {
            if (next != par) {
                depth[next] = depth[node] + 1;
                dfs(next, node);
            }
        }
    }

    static int lca(int a, int b) {
        if (depth[a] < depth[b]) {
            int tmp = a; a = b; b = tmp;
        }

        // ê¹Šì´ ë§ì¶”ê¸°
        for (int k = MAX_LOG - 1; k >= 0; k--) {
            if (depth[a] - depth[b] >= (1 << k)) {
                a = parent[a][k];
            }
        }

        if (a == b) return a;

        // ë™ì‹œì— ë¶€ëª¨ë¡œ ì˜¬ë¼ê°€ê¸°
        for (int k = MAX_LOG - 1; k >= 0; k--) {
            if (parent[a][k] != 0 && parent[a][k] != parent[b][k]) {
                a = parent[a][k];
                b = parent[b][k];
            }
        }

        return parent[a][0];
    }
}
```