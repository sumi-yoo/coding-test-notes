# BOJ 11438 - LCA 2

## 📌 문제 링크
[https://www.acmicpc.net/problem/11438](https://www.acmicpc.net/problem/11438)

---

## 📖 문제 요약
- 루트가 1인 트리가 주어짐.
- 두 노드 `a`, `b`가 주어질 때, **가장 가까운 공통 조상(LCA)**를 구하는 문제.
- 트리의 크기: 최대 `100,000` 노드, 쿼리 최대 `100,000`.

---

## 💡 접근 방법
1. **트리 입력 받기**
   - 인접 리스트로 트리를 저장.

2. **부모와 깊이 계산**
   - DFS 또는 BFS를 통해 각 노드의 부모(`parent[node][0]`)와 깊이(`depth[node]`)를 기록.

3. **Binary Lifting**
   - parent[node][k] = node의 2^k 번째 조상을 미리 계산
   - k는 0부터 log2(N)까지

4. **LCA 찾기**
   - 두 노드의 깊이를 맞춤
   - 2^k 점프를 이용해 동시에 위로 올라가면서 공통 조상 찾기

---

## ⏱️ 시간 복잡도
- 전처리: O(N log N)
- 쿼리: O(log N)
- N, Q ≤ 100,000 → 충분히 통과

---

## 📝 풀이 코드 (Java)

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N, M;
    static ArrayList<Integer>[] tree;
    static int[][] parent;
    static int[] depth;
    static int MAX_LOG;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st;

        N = Integer.parseInt(br.readLine());
        MAX_LOG = (int)(Math.log(N) / Math.log(2)) + 1;

        tree = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) tree[i] = new ArrayList<>();

        for (int i = 0; i < N - 1; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            tree[a].add(b);
            tree[b].add(a);
        }

        parent = new int[N + 1][MAX_LOG];
        depth = new int[N + 1];

        // DFS로 depth와 parent[?][0] 계산
        dfs(1, 0);

        // Binary Lifting 전처리
        for (int k = 1; k < MAX_LOG; k++) {
            for (int v = 1; v <= N; v++) {
                parent[v][k] = parent[parent[v][k - 1]][k - 1];
            }
        }

        M = Integer.parseInt(br.readLine());
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            bw.write(lca(a, b) + "\n");
        }

        br.close();
        bw.flush();
        bw.close();
    }

    static void dfs(int node, int par) {
        parent[node][0] = par;
        for (int next : tree[node]) {
            if (next != par) {
                depth[next] = depth[node] + 1;
                dfs(next, node);
            }
        }
    }

    static int lca(int a, int b) {
        if (depth[a] < depth[b]) {
            int tmp = a; a = b; b = tmp;
        }

        // 깊이 맞추기
        for (int k = MAX_LOG - 1; k >= 0; k--) {
            if (depth[a] - depth[b] >= (1 << k)) {
                a = parent[a][k];
            }
        }

        if (a == b) return a;

        // 동시에 부모로 올라가기
        for (int k = MAX_LOG - 1; k >= 0; k--) {
            if (parent[a][k] != 0 && parent[a][k] != parent[b][k]) {
                a = parent[a][k];
                b = parent[b][k];
            }
        }

        return parent[a][0];
    }
}
```