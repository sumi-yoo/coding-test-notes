# BOJ 1197 - 최소 스패닝 트리

## 문제 링크
[https://www.acmicpc.net/problem/1197](https://www.acmicpc.net/problem/1197)

---

## 문제 요약
- N개의 정점, M개의 간선이 있는 그래프가 주어짐
- 모든 정점을 연결하면서 **간선의 가중치 합이 최소**가 되도록 하는 트리(MST)를 찾기
- 출력: MST의 총 가중치

---

## 핵심 아이디어
- MST를 구하는 대표 알고리즘: **크루스칼(Kruskal)**
1. 모든 간선을 가중치 오름차순으로 정렬
2. 사이클을 만들지 않는 간선만 선택
3. Union-Find(Disjoint Set)으로 사이클 체크

- 시간 복잡도: O(M log M) (간선 정렬 때문)

---

## 알고리즘 흐름
1. 간선 클래스 정의 및 가중치 비교
2. Union-Find 배열 초기화
3. 간선 가중치 오름차순 정렬
4. 간선을 하나씩 확인하며
   - 서로 다른 집합이면 선택하고 union 수행
   - 같은 집합이면 사이클 → 선택하지 않음
5. 모든 간선 처리 후 선택된 간선들의 가중치 합 출력

---

## 전체 코드 (Java)

```java
import java.io.*;
import java.util.*;

public class Main {

    static int N, M;
    static Edge[] edges;
    static int[] parent;

    static class Edge implements Comparable<Edge> {
        int from, to, weight;

        Edge(int from, int to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }

        @Override
        public int compareTo(Edge o) {
            return this.weight - o.weight;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        edges = new Edge[M];
        parent = new int[N + 1];

        // 부모 초기화
        for (int i = 1; i <= N; i++) parent[i] = i;

        // 간선 정보 입력
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            edges[i] = new Edge(u, v, w);
        }

        // 가중치 오름차순 정렬
        Arrays.sort(edges);

        long result = 0;
        for (Edge e : edges) {
            if (find(e.from) != find(e.to)) {
                union(e.from, e.to);
                result += e.weight;
            }
        }

        System.out.println(result);
    }

    // Union-Find: find
    static int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    // Union-Find: union
    static void union(int a, int b) {
        a = find(a);
        b = find(b);
        if (a != b) parent[b] = a;
    }
}
```