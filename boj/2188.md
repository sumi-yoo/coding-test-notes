# BOJ 2188 - 축사 배정

## 문제 링크
https://www.acmicpc.net/problem/2188

## 문제 요약
- 소 N마리, 축사 M개.
- 각 소는 들어가고 싶은 축사 목록을 가지고 있음.
- 제약:
  - 한 소는 하나의 축사만 배정 가능.
  - 한 축사에는 소 한 마리만 배정 가능.
- 목표: 배정 가능한 소의 **최대 수(최대 매칭 크기)** 출력.

## 핵심 아이디어
- 전형적인 **이분 그래프 최대 매칭** 문제.
  - 왼쪽 집합: 소(1..N)
  - 오른쪽 집합: 축사(1..M)
  - 간선: 소 i가 원하는 축사 j
- **DFS를 이용한 증가 경로(augmenting path) 탐색**으로 매칭을 한 마리씩 늘린다.
  - 소 i에서 시작해 원하는 축사들을 탐색:
    - 빈 축사면 즉시 배정.
    - 이미 배정된 축사라면, 해당 축사에 있는 소를 다른 축사로 재배치(DFS) 시도.
- 매 소마다 visited(축사 방문 체크) 배열을 초기화하여 중복 탐색 방지.

## 알고리즘 흐름
1. 입력으로 각 소의 희망 축사 리스트를 인접 리스트로 저장.
2. matchBarn[j] = 축사 j에 배정된 소 번호(없으면 0).
3. 소 i = 1..N에 대해:
   - visited[1..M] = false 초기화
   - dfs(i)가 true면 정답++.
4. 정답 출력.

## 시간 복잡도
- DFS 기반 이분 매칭: **O(N × M)** (최악치에서 간선 수에 비례)
- N, M ≤ 200 이므로 충분히 통과.

## 구현 팁 / 주의
- 입력 형식: 각 소 i 줄에 `k b1 b2 ... bk` (먼저 개수 k, 그 다음 희망 축사 번호들).
- 매 소마다 visited[]를 새로 초기화해야 무한 재귀/중복 탐색을 막을 수 있다.
- matchBarn은 “축사 기준” 매칭 테이블이다(오른쪽 집합 기준으로 들고 있으면 구현이 깔끔함).

## 전체 코드 (Java)
```java
import java.io.*;
import java.util.*;

public class Main {
    static int N, M;
    static List<Integer>[] wants;   // wants[cow] = 해당 소가 원하는 축사 목록
    static int[] matchBarn;         // matchBarn[barn] = 이 축사에 배정된 소 (없으면 0)
    static boolean[] visited;       // DFS에서 축사 방문 체크 (매 소마다 초기화)

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        wants = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) wants[i] = new ArrayList<>();

        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            int k = Integer.parseInt(st.nextToken());
            for (int t = 0; t < k; t++) {
                int barn = Integer.parseInt(st.nextToken());
                wants[i].add(barn);
            }
        }

        matchBarn = new int[M + 1];
        int answer = 0;

        for (int cow = 1; cow <= N; cow++) {
            visited = new boolean[M + 1];
            if (dfs(cow)) answer++;
        }

        System.out.println(answer);
    }

    // 소 cow를 어떤 축사에 배정할 수 있으면 true
    static boolean dfs(int cow) {
        for (int barn : wants[cow]) {
            if (visited[barn]) continue;
            visited[barn] = true;

            // 빈 축사이거나, 현재 배정된 소를 다른 축사로 옮길 수 있으면 점유
            if (matchBarn[barn] == 0 || dfs(matchBarn[barn])) {
                matchBarn[barn] = cow;
                return true;
            }
        }
        return false;
    }
}
```