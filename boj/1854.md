# BOJ 1854 - Kë²ˆì§¸ ìµœë‹¨ê²½ë¡œ ì°¾ê¸°

## ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/1854](https://www.acmicpc.net/problem/1854)

---

## ğŸ§¾ ë¬¸ì œ ìš”ì•½

- ë°©í–¥ ê·¸ë˜í”„ê°€ ì£¼ì–´ì§ (Nê°œì˜ ë„ì‹œ, Mê°œì˜ ë„ë¡œ)
- 1ë²ˆ ë„ì‹œì—ì„œ ì¶œë°œí•´ì„œ ë‚˜ë¨¸ì§€ ëª¨ë“  ë„ì‹œë¡œ ê°€ëŠ” **Kë²ˆì§¸ ìµœë‹¨ ê²½ë¡œì˜ ë¹„ìš©**ì„ ì¶œë ¥
- Kë²ˆì§¸ ìµœë‹¨ ê²½ë¡œê°€ ì—†ëŠ” ê²½ìš° `-1` ì¶œë ¥

## ğŸ“Œ ì…ë ¥

- N (1 â‰¤ N â‰¤ 1,000)
- M (1 â‰¤ M â‰¤ 100,000)
- K (1 â‰¤ K â‰¤ 100)
- ì´í›„ Mê°œì˜ ì¤„ì— ê°„ì„  ì •ë³´: `u v w` (uì—ì„œ vë¡œ ê°€ëŠ” ê°€ì¤‘ì¹˜ w ë„ë¡œ)

## âœ… ì¶œë ¥

- 1ë²ˆ ë„ì‹œì—ì„œ ê° ë„ì‹œë¡œ ê°€ëŠ” **Kë²ˆì§¸ ìµœë‹¨ ê²½ë¡œì˜ ë¹„ìš©ì„ í•œ ì¤„ì— í•˜ë‚˜ì”© ì¶œë ¥**
- í•´ë‹¹ ê²½ë¡œê°€ ì—†ë‹¤ë©´ `-1` ì¶œë ¥

---

## ğŸ’¡ ì•„ì´ë””ì–´

- ì¼ë°˜ì ì¸ ë‹¤ìµìŠ¤íŠ¸ë¼ëŠ” **ìµœë‹¨ ê±°ë¦¬ 1ê°œë§Œ** ì €ì¥
- ì´ ë¬¸ì œëŠ” **Kë²ˆì§¸ ìµœë‹¨ ê±°ë¦¬ê¹Œì§€ ì €ì¥**í•´ì•¼ í•˜ë¯€ë¡œ ìš°ì„ ìˆœìœ„ íë¥¼ ê° ì •ì ë§ˆë‹¤ í™œìš©

## ğŸ§  ì•Œê³ ë¦¬ì¦˜

- `dist[i]` = 1ë²ˆ ë„ì‹œì—ì„œ ië²ˆ ë„ì‹œê¹Œì§€ ë„ë‹¬í•˜ëŠ” ê²½ë¡œì˜ ë¹„ìš©ì„ ì €ì¥í•˜ëŠ” **ìµœëŒ€ í™(PriorityQueue)**
  - Kê°œê¹Œì§€ë§Œ ìœ ì§€
- ìš°ì„ ìˆœìœ„ íë¡œ ë¹„ìš©ì´ ë‚®ì€ ìˆœì„œëŒ€ë¡œ íƒìƒ‰
- ë‹¤ìŒ ì •ì ê¹Œì§€ ê°€ëŠ” ê²½ë¡œì˜ ë¹„ìš©ì„ `dist[next]`ì— ë„£ë˜,
  - sizeê°€ Kë³´ë‹¤ ì‘ìœ¼ë©´ ê·¸ëƒ¥ ë„£ê³ 
  - Kê°œ ì°¼ìœ¼ë©´ peek()ë³´ë‹¤ ì‘ì„ ë•Œë§Œ ëŒ€ì²´ (ìµœëŒ“ê°’ ì œê±°)

---

## ğŸ§¾ ìë°” ì½”ë“œ

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m, k;
    static List<Node>[] graph;
    static PriorityQueue<Integer>[] dist;

    static class Node implements Comparable<Node> {
        int idx, cost;

        Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());

        graph = new ArrayList[n + 1];
        dist = new PriorityQueue[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
            dist[i] = new PriorityQueue<>(Collections.reverseOrder());
        }

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            graph[a].add(new Node(b, c));
        }

        dijkstra(1);

        for (int i = 1; i <= n; i++) {
            if (dist[i].size() < k) {
                bw.write(-1 + "\n");
            } else {
                bw.write(dist[i].peek() + "\n");
            }
        }

        bw.flush();
        bw.close();
        br.close();
    }

    static void dijkstra(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        dist[start].offer(0);

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            for (Node next: graph[now.idx]) {
                int nextDist = next.cost + now.cost;

                if (dist[next.idx].size() < k) {
                    dist[next.idx].offer(nextDist);
                    pq.offer(new Node(next.idx, nextDist));
                } else if (dist[next.idx].peek() > nextDist) {
                    dist[next.idx].poll();
                    dist[next.idx].offer(nextDist);
                    pq.offer(new Node(next.idx, nextDist));
                }
            }
        }
    }
}
```