# BOJ 1854 - K번째 최단경로 찾기

## 문제 링크
[https://www.acmicpc.net/problem/1854](https://www.acmicpc.net/problem/1854)

---

## 🧾 문제 요약

- 방향 그래프가 주어짐 (N개의 도시, M개의 도로)
- 1번 도시에서 출발해서 나머지 모든 도시로 가는 **K번째 최단 경로의 비용**을 출력
- K번째 최단 경로가 없는 경우 `-1` 출력

## 📌 입력

- N (1 ≤ N ≤ 1,000)
- M (1 ≤ M ≤ 100,000)
- K (1 ≤ K ≤ 100)
- 이후 M개의 줄에 간선 정보: `u v w` (u에서 v로 가는 가중치 w 도로)

## ✅ 출력

- 1번 도시에서 각 도시로 가는 **K번째 최단 경로의 비용을 한 줄에 하나씩 출력**
- 해당 경로가 없다면 `-1` 출력

---

## 💡 아이디어

- 일반적인 다익스트라는 **최단 거리 1개만** 저장
- 이 문제는 **K번째 최단 거리까지 저장**해야 하므로 우선순위 큐를 각 정점마다 활용

## 🧠 알고리즘

- `dist[i]` = 1번 도시에서 i번 도시까지 도달하는 경로의 비용을 저장하는 **최대 힙(PriorityQueue)**
  - K개까지만 유지
- 우선순위 큐로 비용이 낮은 순서대로 탐색
- 다음 정점까지 가는 경로의 비용을 `dist[next]`에 넣되,
  - size가 K보다 작으면 그냥 넣고
  - K개 찼으면 peek()보다 작을 때만 대체 (최댓값 제거)

---

## 🧾 자바 코드

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m, k;
    static List<Node>[] graph;
    static PriorityQueue<Integer>[] dist;

    static class Node implements Comparable<Node> {
        int idx, cost;

        Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());

        graph = new ArrayList[n + 1];
        dist = new PriorityQueue[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
            dist[i] = new PriorityQueue<>(Collections.reverseOrder());
        }

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            graph[a].add(new Node(b, c));
        }

        dijkstra(1);

        for (int i = 1; i <= n; i++) {
            if (dist[i].size() < k) {
                bw.write(-1 + "\n");
            } else {
                bw.write(dist[i].peek() + "\n");
            }
        }

        bw.flush();
        bw.close();
        br.close();
    }

    static void dijkstra(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        dist[start].offer(0);

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            for (Node next: graph[now.idx]) {
                int nextDist = next.cost + now.cost;

                if (dist[next.idx].size() < k) {
                    dist[next.idx].offer(nextDist);
                    pq.offer(new Node(next.idx, nextDist));
                } else if (dist[next.idx].peek() > nextDist) {
                    dist[next.idx].poll();
                    dist[next.idx].offer(nextDist);
                    pq.offer(new Node(next.idx, nextDist));
                }
            }
        }
    }
}
```