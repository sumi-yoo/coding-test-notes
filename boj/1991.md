# BOJ 1991 - 트리 순회

## 문제 링크
[https://www.acmicpc.net/problem/1991](https://www.acmicpc.net/problem/1991)

---

## 문제 요약
- 이진 트리의 노드 개수 `N`(1 ≤ N ≤ 26)이 주어진다.
- 이후 `N`개의 줄에 걸쳐 **루트, 왼쪽 자식, 오른쪽 자식** 정보가 주어진다.
  - 자식이 없는 경우 `.` 으로 표시.
- 세 가지 순회 결과를 출력하라:
  1. **전위 순회 (Preorder)** : 루트 → 왼쪽 → 오른쪽
  2. **중위 순회 (Inorder)** : 왼쪽 → 루트 → 오른쪽
  3. **후위 순회 (Postorder)** : 왼쪽 → 오른쪽 → 루트

---

## 핵심 아이디어
- 노드 개수가 최대 26이므로 단순 재귀로 해결 가능.
- 입력으로 주어진 관계를 **배열 또는 맵**에 저장한 뒤,
  재귀 함수를 통해 각 순회를 구현한다.

---

## 알고리즘 흐름
1. 입력으로 주어진 노드 관계를 저장:
   - `left[node]` = 왼쪽 자식
   - `right[node]` = 오른쪽 자식
2. 세 가지 재귀 함수를 구현:
   - `preorder(node)`
   - `inorder(node)`
   - `postorder(node)`
3. 루트 `'A'`부터 시작해서 탐색.


---

## 전체 코드 (Java)
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] left = new int[26];
    static int[] right = new int[26];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            char root = st.nextToken().charAt(0);
            char l = st.nextToken().charAt(0);
            char r = st.nextToken().charAt(0);

            if (l == '.') left[root - 'A'] = -1;
            else left[root - 'A'] = l - 'A';

            if (r == '.') right[root - 'A'] = -1;
            else right[root - 'A'] = r - 'A';
        }

        StringBuilder sb = new StringBuilder();
        preorder(0, sb); sb.append("\n");
        inorder(0, sb); sb.append("\n");
        postorder(0, sb);

        System.out.println(sb);
    }

    // 전위 순회: 루트 → 왼쪽 → 오른쪽
    static void preorder(int node, StringBuilder sb) {
        if (node == -1) return;
        sb.append((char)(node + 'A'));
        preorder(left[node], sb);
        preorder(right[node], sb);
    }

    // 중위 순회: 왼쪽 → 루트 → 오른쪽
    static void inorder(int node, StringBuilder sb) {
        if (node == -1) return;
        inorder(left[node], sb);
        sb.append((char)(node + 'A'));
        inorder(right[node], sb);
    }

    // 후위 순회: 왼쪽 → 오른쪽 → 루트
    static void postorder(int node, StringBuilder sb) {
        if (node == -1) return;
        postorder(left[node], sb);
        postorder(right[node], sb);
        sb.append((char)(node + 'A'));
    }
}
```