# BOJ 14938 - ì„œê°•ê·¸ë¼ìš´ë“œ

## ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/14938](https://www.acmicpc.net/problem/14938)

---

## ğŸ§© ë¬¸ì œ ì„¤ëª…

- ì—¬ëŸ¬ ì§€ì—­ì´ ìˆê³ , ê° ì§€ì—­ë§ˆë‹¤ ì•„ì´í…œì´ ìˆë‹¤.
- ì§€ì—­ë“¤ ê°„ì— ê¸¸ì´ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©°, ê¸¸ë§ˆë‹¤ ì´ë™ ê±°ë¦¬ê°€ ì£¼ì–´ì§„ë‹¤.
- í•œ ì§€ì—­ì—ì„œ ì¶œë°œí•´, ì´ë™ ê±°ë¦¬ê°€ ìµœëŒ€ M ì´í•˜ì¸ ë‹¤ë¥¸ ì§€ì—­ë“¤ì—ì„œ ì•„ì´í…œì„ íšë“í•  ìˆ˜ ìˆë‹¤.
- ì´ë™ ê±°ë¦¬ê°€ ìµœëŒ€ M ì´ë‚´ì¸ ì§€ì—­ë“¤ì˜ ì•„ì´í…œ ìˆ˜ í•©ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

---

## ğŸ“Œ ì…ë ¥

- ì²« ì¤„: N(ì§€ì—­ ê°œìˆ˜), M(ìµœëŒ€ ì´ë™ ê±°ë¦¬), R(ê¸¸ ê°œìˆ˜)
- ë‘ ë²ˆì§¸ ì¤„: ê° ì§€ì—­ë³„ ì•„ì´í…œ ê°œìˆ˜ (1 ~ N)
- ë‹¤ìŒ Rì¤„: ê¸¸ ì •ë³´ (a, b, l) - aì™€ bëŠ” ì§€ì—­ ë²ˆí˜¸, lì€ ê±°ë¦¬

---

## ğŸ“¤ ì¶œë ¥

- í•œ ì§€ì—­ì—ì„œ ì¶œë°œí•˜ì—¬ ì´ë™ ê±°ë¦¬ M ì´ë‚´ì— ìˆëŠ” ì§€ì—­ë“¤ì˜ ì•„ì´í…œ ìˆ˜ í•©ì˜ ìµœëŒ€ê°’ ì¶œë ¥

---

## âœ… ì•„ì´ë””ì–´

- ê° ì§€ì—­ì„ ì¶œë°œì§€ë¡œ í•˜ì—¬ ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ìˆ˜í–‰
- ì¶œë°œì§€ì—ì„œ ê° ì§€ì—­ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•¨
- ê±°ë¦¬ê°€ M ì´ë‚´ì¸ ì§€ì—­ë“¤ì˜ ì•„ì´í…œ í•©ì„ êµ¬í•˜ê³  ìµœëŒ€ê°’ ì €ì¥
- Nê°œì˜ ì§€ì—­ì— ëŒ€í•´ ë°˜ë³µ í›„ ìµœëŒ€ ì•„ì´í…œ ê°œìˆ˜ ì¶œë ¥

---

## ğŸ“˜ ì•Œê³ ë¦¬ì¦˜

1. ê·¸ë˜í”„ë¥¼ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„
2. ê° ì§€ì—­ë³„ ì•„ì´í…œ ìˆ˜ ë°°ì—´ë¡œ ì €ì¥
3. ë‹¤ìµìŠ¤íŠ¸ë¼ í•¨ìˆ˜ë¡œ ì¶œë°œì§€ì—ì„œ ëª¨ë“  ì§€ì—­ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
4. ê±°ë¦¬ M ì´í•˜ì¸ ì§€ì—­ë“¤ì˜ ì•„ì´í…œ ìˆ˜ í•© ê³„ì‚°
5. ìµœëŒ“ê°’ ê°±ì‹ 
6. ëª¨ë“  ì§€ì—­ì— ëŒ€í•´ 3~5 ë°˜ë³µ

---

## ğŸ’» ì½”ë“œ (Java)

```java
import java.io.*;
import java.util.*;

public class Main {

    static final int INF = 1_000_000_000;
    static int n, m, r;
    static int[] items;
    static List<Node>[] edge;

    static class Node implements Comparable<Node> {
        int idx, cost;

        Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return 0;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        r = Integer.parseInt(st.nextToken());

        items = new int[n + 1];
        edge = new ArrayList[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            items[i] = Integer.parseInt(st.nextToken());
            edge[i] = new ArrayList<>();
        }

        for (int i = 0; i < r; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int l = Integer.parseInt(st.nextToken());

            edge[a].add(new Node(b, l));
            edge[b].add(new Node(a, l));
        }

        int max = 0;
        for (int i = 1; i <= n; i++) {
            int[] dist = dijkstra(i);
            int total = 0;
            for (int j = 1; j <= n; j++) {
                if (dist[j] <= m) {
                    total += items[j];
                }
            }
            max = Math.max(max, total);
        }

        bw.write(max + "\n");

        bw.flush();
        bw.close();
        br.close();
    }

    static int[] dijkstra(int start) {
        int[] dist = new int[n + 1];
        Arrays.fill(dist, INF);
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            for (Node next: edge[now.idx]) {
                int nextCost = now.cost + next.cost;
                if (dist[next.idx] > nextCost) {
                    dist[next.idx] = nextCost;
                    pq.offer(new Node(next.idx, nextCost));
                }
            }
        }

        return dist;
    }
}
```