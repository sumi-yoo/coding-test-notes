# BOJ 14938 - 서강그라운드

## 문제 링크
[https://www.acmicpc.net/problem/14938](https://www.acmicpc.net/problem/14938)

---

## 🧩 문제 설명

- 여러 지역이 있고, 각 지역마다 아이템이 있다.
- 지역들 간에 길이 연결되어 있으며, 길마다 이동 거리가 주어진다.
- 한 지역에서 출발해, 이동 거리가 최대 M 이하인 다른 지역들에서 아이템을 획득할 수 있다.
- 이동 거리가 최대 M 이내인 지역들의 아이템 수 합의 최댓값을 구하는 문제이다.

---

## 📌 입력

- 첫 줄: N(지역 개수), M(최대 이동 거리), R(길 개수)
- 두 번째 줄: 각 지역별 아이템 개수 (1 ~ N)
- 다음 R줄: 길 정보 (a, b, l) - a와 b는 지역 번호, l은 거리

---

## 📤 출력

- 한 지역에서 출발하여 이동 거리 M 이내에 있는 지역들의 아이템 수 합의 최대값 출력

---

## ✅ 아이디어

- 각 지역을 출발지로 하여 다익스트라를 수행
- 출발지에서 각 지역까지 최단 거리를 구함
- 거리가 M 이내인 지역들의 아이템 합을 구하고 최대값 저장
- N개의 지역에 대해 반복 후 최대 아이템 개수 출력

---

## 📘 알고리즘

1. 그래프를 인접 리스트로 표현
2. 각 지역별 아이템 수 배열로 저장
3. 다익스트라 함수로 출발지에서 모든 지역까지 최단 거리 계산
4. 거리 M 이하인 지역들의 아이템 수 합 계산
5. 최댓값 갱신
6. 모든 지역에 대해 3~5 반복

---

## 💻 코드 (Java)

```java
import java.io.*;
import java.util.*;

public class Main {

    static final int INF = 1_000_000_000;
    static int n, m, r;
    static int[] items;
    static List<Node>[] edge;

    static class Node implements Comparable<Node> {
        int idx, cost;

        Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return 0;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        r = Integer.parseInt(st.nextToken());

        items = new int[n + 1];
        edge = new ArrayList[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            items[i] = Integer.parseInt(st.nextToken());
            edge[i] = new ArrayList<>();
        }

        for (int i = 0; i < r; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int l = Integer.parseInt(st.nextToken());

            edge[a].add(new Node(b, l));
            edge[b].add(new Node(a, l));
        }

        int max = 0;
        for (int i = 1; i <= n; i++) {
            int[] dist = dijkstra(i);
            int total = 0;
            for (int j = 1; j <= n; j++) {
                if (dist[j] <= m) {
                    total += items[j];
                }
            }
            max = Math.max(max, total);
        }

        bw.write(max + "\n");

        bw.flush();
        bw.close();
        br.close();
    }

    static int[] dijkstra(int start) {
        int[] dist = new int[n + 1];
        Arrays.fill(dist, INF);
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            for (Node next: edge[now.idx]) {
                int nextCost = now.cost + next.cost;
                if (dist[next.idx] > nextCost) {
                    dist[next.idx] = nextCost;
                    pq.offer(new Node(next.idx, nextCost));
                }
            }
        }

        return dist;
    }
}
```