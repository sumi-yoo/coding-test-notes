# BOJ 2042 - 구간 합 구하기

🔗 문제 링크: [https://www.acmicpc.net/problem/2042](https://www.acmicpc.net/problem/2042)

---

## 문제 요약
- 길이 `N`의 수열이 주어짐.
- 다음 연산을 총 `M + K`번 수행:
  1. **값 변경**: `a == 1` → `arr[idx] = val`
  2. **구간 합 구하기**: `a == 2` → `arr[left] ~ arr[right]` 합 출력
- 원소 개수 `N` ≤ 1,000,000, 쿼리 수 `M + K` ≤ 10,000
- 원소 값과 변경 값은 최대 `10^12` → **`long` 사용 필수**

---

## 핵심 아이디어
1. **구간 합**을 빠르게 구하기 위해 **세그먼트 트리** 사용  
   - 일반적으로 합을 매번 `O(N)`에 구하면 시간 초과.
   - 세그먼트 트리를 사용하면:
     - 구간 합 쿼리: `O(log N)`
     - 값 변경 쿼리: `O(log N)`

2. **`long` 사용 이유**  
   - 각 원소 값이 최대 `10^12`이고, N이 최대 `10^6`이므로  
     최악의 경우 구간 합은 `10^12 × 10^6 = 10^18`까지 가능.
   - `int`(약 ±2×10^9)는 범위를 훨씬 넘음 → `long` 사용.

---

## 세그먼트 트리 동작 원리

### 1. 트리 구조
- 배열을 이진 트리 형태로 표현.
- 루트 노드가 전체 구간 합을 저장.
- 왼쪽 자식은 왼쪽 절반 구간 합, 오른쪽 자식은 오른쪽 절반 구간 합을 저장.

### 2. 트리 생성 (build)
- `node`: 현재 노드 번호 (루트=1)
- `start, end`: 현재 노드가 담당하는 구간
- 재귀적으로 왼쪽/오른쪽 구간을 나눠서 트리 채움.
- 리프 노드에 도달하면 배열 값 저장.
- 부모 노드는 왼쪽 + 오른쪽 자식의 합을 저장.

---

### 3. 값 변경 (update)
- `idx`: 변경할 배열 인덱스
- 해당 리프 노드까지 내려가서 값 변경.
- 변경 후 재귀적으로 부모 노드 값 갱신.
- 범위 밖이면 아무 작업도 하지 않음.

---

### 4. 구간 합 조회 (query)
- `left, right`: 구간 합을 구할 범위
- 현재 노드 구간이 완전히 포함되면 값 반환.
- 전혀 겹치지 않으면 0 반환.
- 일부만 겹치면 왼쪽/오른쪽 자식에 재귀 호출 후 합산.

---

## 💻 코드

```java
import java.io.*;
import java.util.*;

public class Main {

    static long arr[];
    static long tree[];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        arr = new long[N + 1];
        tree = new long[4 * N];

        for (int i = 1; i <= N; i++) {
            arr[i] = Long.parseLong(br.readLine());
        }

        build(1, 1, N);

        for (int i = 0; i < M + K; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());

            if (a == 1) {
                int inx = Integer.parseInt(st.nextToken());
                long val = Long.parseLong(st.nextToken());
                update(1, 1, N, inx, val);
            } else {
                int left = Integer.parseInt(st.nextToken());
                int right = Integer.parseInt(st.nextToken());
                bw.write(query(1, 1, N, left, right) + "\n");
            }
        }

        bw.flush();
        bw.close();
        br.close();
    }

    static void build(int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }

        int mid = (start + end) / 2;

        build(node * 2, start, mid);
        build(node * 2 + 1, mid + 1, end);

        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }

    static void update(int node, int start, int end, int idx, long val) {
        if (idx < start || end < idx) return;

        if (start == end) {
            tree[node] = val;
            return;
        }

        int mid = (start + end) / 2;

        update(node * 2, start, mid, idx, val);
        update(node * 2 + 1, mid + 1, end, idx, val);

        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }

    static long query(int node, int start, int end, int left, int right) {
        if (right < start || end < left) return 0;

        if (left <= start && end <= right) {
            return tree[node];
        }

        int mid = (start + end) / 2;

        return query(node * 2, start, mid, left, right)
                + query(node * 2 + 1, mid + 1, end, left, right);
    }
}
```