# BOJ 11779 - 최소비용 구하기 2

## 문제 링크
[https://www.acmicpc.net/problem/11779](https://www.acmicpc.net/problem/11779)

## 문제 설명
N개의 도시와 M개의 버스가 있다.  
각 버스는 출발 도시, 도착 도시, 비용이 주어지며, 한 도시에서 다른 도시로 이동하는 최소 비용을 구하는 문제.  

**추가 조건**: 최소 비용뿐만 아니라, 그 경로에 포함되는 도시의 개수와 경로 자체도 출력해야 한다.

- 도시 번호: 1번 ~ N번
- 버스 정보: (출발 도시, 도착 도시, 비용)
- 시작 도시에서 도착 도시까지의 최소 비용과 경로를 출력

## 제약 조건
- 1 ≤ N ≤ 1,000
- 1 ≤ M ≤ 100,000
- 비용 C: 0 < C ≤ 100,000

## 문제 풀이 아이디어
- **다익스트라 알고리즘**으로 최소 비용 계산
- 최단 거리만 구하는 것이 아니라, **이전 노드(prev)** 배열을 사용해 경로 복원
- 다익스트라 수행 후 `prev`를 거슬러 올라가 경로를 역순으로 구하고, 뒤집어서 출력

## 알고리즘 절차
1. 인접 리스트(`List<Node>[]`)로 그래프 저장
2. `dist[]` 배열을 INF로 초기화
3. 시작 도시의 거리를 0으로 설정 후 우선순위 큐에 삽입
4. 큐에서 꺼낸 노드에 대해 연결된 노드의 거리를 갱신  
   - 더 짧은 경로 발견 시 `prev[다음노드] = 현재노드` 저장
5. 도착 도시까지의 최소 비용과 경로 복원

## Java 코드
```java
import java.io.*;
import java.util.*;

public class Main {

    static final int INF = 1_000_000_000;
    static int N;
    static List<Node>[] graph;
    static int[] prev;

    static class Node implements Comparable<Node> {
        int idx, cost;

        Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }


        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        int M = Integer.parseInt(br.readLine());

        prev = new int[N + 1];
        graph = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            graph[a].add(new Node(b, c));
        }

        StringTokenizer st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken());
        int end = Integer.parseInt(st.nextToken());

        int[] distFromStart = dijkstra(start);
        bw.write(distFromStart[end] + " \n");

        List<Integer> path = new ArrayList<>();
        int cur = end;
        while (cur > 0) {
            path.add(cur);
            cur = prev[cur];
        }
        Collections.reverse(path);

        bw.write(path.size() + " \n");
        for (int city : path) {
            bw.write(city + " ");
        }

        bw.flush();
        bw.close();
        br.close();
    }

    static int[] dijkstra(int start) {
        int[] dist = new int[N + 1];
        Arrays.fill(dist, INF);
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            if (now.cost > dist[now.idx]) continue;

            for (Node next: graph[now.idx]) {
                int nextCost = next.cost + now.cost;
                if (nextCost < dist[next.idx]) {
                    dist[next.idx] = nextCost;
                    prev[next.idx] = now.idx;
                    pq.offer(new Node(next.idx, nextCost));
                }
            }
        }

        return dist;
    }
}
```