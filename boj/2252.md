# BOJ 2252 - 줄 세우기

## 문제 링크
https://www.acmicpc.net/problem/2252

## 문제 요약
- 학생 N명, 키 비교 M개가 주어짐  
- A B → A가 B보다 앞에 서야 함 (유향 간선)  
- 모든 학생이 조건을 만족하도록 줄 세우기  
- 가능한 답 중 하나 출력  

## 핵심 아이디어
- 위상 정렬 (Topological Sort) 문제  
- 사이클 없는 방향 그래프(DAG)에서 순서를 정하는 방법  
- Kahn’s Algorithm (진입 차수 기반 BFS) 사용  
- 시간 복잡도: O(N + M)  

## 알고리즘 흐름
1. 그래프 & 진입 차수 배열 생성  
2. 진입 차수가 0인 노드를 큐에 삽입  
3. 큐에서 하나씩 꺼내 출력하면서 연결된 노드들의 진입 차수 감소  
4. 새롭게 진입 차수가 0이 되면 큐에 삽입  
5. 큐가 빌 때까지 반복 → 위상 정렬 결과 완성  

## 전체 코드 (Java)
```java
import java.io.*;
import java.util.*;

public class Main {

    static ArrayList<Integer>[] edges;
    static int[] degree;
    static int N;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        degree = new int[N + 1];
        edges = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) {
            edges[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            edges[a].add(b);
            degree[b]++;
        }

        topologySort();

        br.close();
    }

    static void topologySort() {
        Queue<Integer> queue = new ArrayDeque<>();

        for (int i = 1; i <= N; i++) {
            if (degree[i] == 0) {
                queue.offer(i);
            }
        }

        while (!queue.isEmpty()) {
            int now = queue.poll();
            System.out.print(now + " ");

            for (int next : edges[now]) {
                degree[next]--;
                if (degree[next] == 0) {
                    queue.offer(next);
                }
            }
        }
    }
}
```