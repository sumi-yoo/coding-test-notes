# BOJ 10845 - í

[ë¬¸ì œ ë§í¬ ğŸ”—](https://www.acmicpc.net/problem/10845)

---

## ğŸ“š ë¬¸ì œ ì„¤ëª…
ì •ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” íë¥¼ êµ¬í˜„í•˜ê³ , ì£¼ì–´ì§„ ëª…ë ¹ì„ ì²˜ë¦¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.  
ëª…ë ¹ì€ ì´ 6ê°€ì§€ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.

- `push X`: ì •ìˆ˜ Xë¥¼ íì— ë„£ëŠ”ë‹¤.
- `pop`: íì—ì„œ ê°€ì¥ ì•ì— ìˆëŠ” ì •ìˆ˜ë¥¼ ë¹¼ê³  ì¶œë ¥. íê°€ ë¹„ì–´ìˆìœ¼ë©´ -1 ì¶œë ¥.
- `size`: íì— ë“¤ì–´ìˆëŠ” ì •ìˆ˜ ê°œìˆ˜ë¥¼ ì¶œë ¥.
- `empty`: íê°€ ë¹„ì–´ìˆìœ¼ë©´ 1, ì•„ë‹ˆë©´ 0 ì¶œë ¥.
- `front`: íì˜ ê°€ì¥ ì•ì— ìˆëŠ” ì •ìˆ˜ë¥¼ ì¶œë ¥. ë¹„ì–´ìˆìœ¼ë©´ -1 ì¶œë ¥.
- `back`: íì˜ ê°€ì¥ ë’¤ì— ìˆëŠ” ì •ìˆ˜ë¥¼ ì¶œë ¥. ë¹„ì–´ìˆìœ¼ë©´ -1 ì¶œë ¥.

---

## ğŸ’¡ í’€ì´ ì•„ì´ë””ì–´
- `LinkedList` í´ë˜ìŠ¤ë¥¼ íë¡œ ì‚¬ìš©í•˜ì—¬ `addLast()`, `poll()`, `peek()`, `getLast()` ë©”ì„œë“œ í™œìš©.
- ëª…ë ¹ì–´ê°€ ë§ê³  ë¹ ë¥¸ ì…ì¶œë ¥ì´ í•„ìš”í•˜ë¯€ë¡œ **BufferedReader**ì™€ **BufferedWriter** ì‚¬ìš©.
- `switch` ë¬¸ìœ¼ë¡œ ëª…ë ¹ì–´ë¥¼ êµ¬ë¶„í•´ ì²˜ë¦¬.

---

## ğŸ“ ì½”ë“œ

```java
// Java code
import java.io.*;
import java.util.LinkedList;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st;

        int N = Integer.parseInt(br.readLine());
        LinkedList<Integer> queue = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            switch (st.nextToken()) {
                case "push":
                    queue.addLast(Integer.parseInt(st.nextToken()));
                    break;
                case "pop":
                    bw.write((queue.isEmpty() ? -1 : queue.poll()) + "\n");
                    break;
                case "size":
                    bw.write(queue.size() + "\n");
                    break;
                case "empty":
                    bw.write((queue.isEmpty() ? 1 : 0) + "\n");
                    break;
                case "front":
                    bw.write((queue.isEmpty() ? -1 : queue.peek()) + "\n");
                    break;
                case "back":
                    bw.write((queue.isEmpty() ? -1 : queue.getLast()) + "\n");
                    break;
            }
        }
        
        bw.flush();
        bw.close();
        br.close();
    }
}