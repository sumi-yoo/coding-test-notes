# BOJ 11725 - 트리의 부모 찾기

## 문제 링크
[https://www.acmicpc.net/problem/11725](https://www.acmicpc.net/problem/11725)

---

## 문제 요약
- 노드의 개수 `N`(2 ≤ N ≤ 100,000)이 주어진다.
- 이후 `N-1`개의 간선이 주어진다. (트리 구조)
- 루트 노드는 항상 `1`이다.
- 각 노드(2번 ~ N번)의 **부모 노드 번호**를 출력하라.

---

## 핵심 아이디어
- 트리는 **사이클이 없는 연결 그래프**.
- 루트가 1번이므로, 1번에서 시작해 DFS 또는 BFS로 탐색하면서  
  방문하는 자식 노드의 **부모를 기록**하면 된다.

---

## 알고리즘 흐름
1. 입력으로 주어진 간선을 이용해 **인접 리스트** 생성.
2. DFS 또는 BFS 탐색을 수행:
   - 현재 노드에서 인접 노드를 방문할 때, 아직 부모가 정해지지 않았다면 → 부모 저장.
3. 탐색 종료 후, 2번 ~ N번 노드의 부모 출력.


---

## 전체 코드
```java
import java.io.*;
import java.util.*;

public class Main {

    static ArrayList<Integer>[] tree;
    static int[] parent;
    static boolean[] visited;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine());
        tree = new ArrayList[N + 1];
        parent = new int[N + 1];
        visited = new boolean[N + 1];

        for (int i = 1; i <= N; i++) {
            tree[i] = new ArrayList<>();
        }

        for (int i = 0; i < N - 1; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            tree[a].add(b);
            tree[b].add(a);
        }

        bfs(1); // 루트 노드 1부터 탐색 시작

        for (int i = 2; i <= N; i++) {
            bw.write(parent[i] + "\n");
        }

        bw.flush();
        bw.close();
        br.close();
    }

    static void bfs(int node) {
        Queue<Integer> queue = new ArrayDeque<>();
        queue.add(node);
        visited[node] = true;

        while (!queue.isEmpty()) {
            int now = queue.poll();

            for (int next : tree[now]) {
                if (!visited[next]) {
                    queue.add(next);
                    parent[next] = now; // 부모 기록
                    visited[next] = true;
                }
            }
        }
    }
}
```