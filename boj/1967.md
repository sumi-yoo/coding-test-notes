# BOJ 1967 - íŠ¸ë¦¬ì˜ ì§€ë¦„2

## ğŸ“Œ ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/1967](https://www.acmicpc.net/problem/1967)

---

## ğŸ“– ë¬¸ì œ ìš”ì•½
- ë£¨íŠ¸ê°€ 1ì¸ íŠ¸ë¦¬ê°€ ì£¼ì–´ì§ (ë…¸ë“œ ê°œìˆ˜ n â‰¤ 10,000).  
- ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ê±°ë¦¬ ì¤‘ ê°€ì¥ ê¸´ ê°’ì„ **íŠ¸ë¦¬ì˜ ì§€ë¦„**ì´ë¼ê³  ì •ì˜.  
- íŠ¸ë¦¬ì˜ ì§€ë¦„ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ ì‘ì„±.

---

## âŒ ë‹¨ìˆœí•œ ì ‘ê·¼
- ëª¨ë“  ë…¸ë“œ ìŒì˜ ê±°ë¦¬ë¥¼ êµ¬í•´ì„œ ìµœëŒ€ê°’ì„ ì°¾ìœ¼ë©´ ë¨.  
- í•˜ì§€ë§Œ ë…¸ë“œ ê°œìˆ˜ê°€ ìµœëŒ€ 10,000ì´ë¯€ë¡œ `O(n^2)` â†’ **ì‹œê°„ ì´ˆê³¼** ë°œìƒ.

---

## ğŸ’¡ í•µì‹¬ ì•„ì´ë””ì–´
**íŠ¸ë¦¬ì˜ ì§€ë¦„ì€ í•­ìƒ ì–´ë–¤ ë…¸ë“œì—ì„œ ê°€ì¥ ë¨¼ ë…¸ë“œì™€, ê·¸ ë…¸ë“œì—ì„œ ë‹¤ì‹œ ê°€ì¥ ë¨¼ ë…¸ë“œ ì‚¬ì´ì˜ ê±°ë¦¬ë‹¤.**

ì¦‰, **ë‘ ë²ˆì˜ íƒìƒ‰(BFS/DFS)** ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

---

## ğŸ› ï¸ ì•Œê³ ë¦¬ì¦˜ íë¦„
1. ì„ì˜ì˜ ë…¸ë“œ(ë³´í†µ 1ë²ˆ)ì—ì„œ BFS/DFS ì‹¤í–‰  
   â†’ ê°€ì¥ ë¨¼ ë…¸ë“œ `farthestNode`ë¥¼ ì°¾ìŒ.  
2. `farthestNode`ì—ì„œ ë‹¤ì‹œ BFS/DFS ì‹¤í–‰  
   â†’ ê°€ì¥ ë¨¼ ê±°ë¦¬ = **íŠ¸ë¦¬ì˜ ì§€ë¦„**.  

---

## âš ï¸ ì˜ˆì™¸ ì²˜ë¦¬
- `n == 1` â†’ ë…¸ë“œê°€ í•˜ë‚˜ë¿ì´ë¯€ë¡œ ì§€ë¦„ì€ `0`.  

---

## â±ï¸ ì‹œê°„ ë³µì¡ë„
- BFS/DFS í•œ ë²ˆ = `O(n)`  
- ë‘ ë²ˆ ì‹¤í–‰ = `O(2n)` â†’ `O(n)`  
- n = 10,000ì´ë¯€ë¡œ ì¶©ë¶„íˆ ê°€ëŠ¥.

---

## âœ… ì½”ë“œ (Java, BFS ì‚¬ìš©)
```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, maxLen, startNode;
    static ArrayList<Edge>[] edge;

    static class Edge {
        int idx, cost;

        Edge(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        n = Integer.parseInt(br.readLine());

        if (n == 1) {
            bw.write("0\n");
            bw.flush();
            bw.close();
            br.close();
            return;
        }

        edge = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            edge[i] = new ArrayList<>();
        }

        for (int i = 1; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            edge[a].add(new Edge(b, c));
            edge[b].add(new Edge(a, c));
        }

        bfs(1);

        maxLen = 0;
        bfs(startNode);

        bw.write(maxLen + "\n");

        bw.flush();
        bw.close();
        br.close();
    }

    static void bfs(int start) {
        Queue<Edge> queue = new ArrayDeque<>();
        queue.offer(new Edge(start, 0));

        boolean[] visited = new boolean[n + 1];
        visited[start] = true;

        while (!queue.isEmpty()) {
            Edge now = queue.poll();

            if (now.cost > maxLen) {
                maxLen = now.cost;
                startNode = now.idx;
            }

            for (Edge next : edge[now.idx]) {
                if (!visited[next.idx]) {
                    visited[next.idx] = true;
                    queue.offer(new Edge(next.idx, now.cost + next.cost));
                }
            }
        }
    }
}
```