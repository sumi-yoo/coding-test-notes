# BOJ 1967 - 트리의 지름2

## 📌 문제 링크
[https://www.acmicpc.net/problem/1967](https://www.acmicpc.net/problem/1967)

---

## 📖 문제 요약
- 루트가 1인 트리가 주어짐 (노드 개수 n ≤ 10,000).  
- 두 노드 사이의 거리 중 가장 긴 값을 **트리의 지름**이라고 정의.  
- 트리의 지름을 구하는 프로그램 작성.

---

## ❌ 단순한 접근
- 모든 노드 쌍의 거리를 구해서 최대값을 찾으면 됨.  
- 하지만 노드 개수가 최대 10,000이므로 `O(n^2)` → **시간 초과** 발생.

---

## 💡 핵심 아이디어
**트리의 지름은 항상 어떤 노드에서 가장 먼 노드와, 그 노드에서 다시 가장 먼 노드 사이의 거리다.**

즉, **두 번의 탐색(BFS/DFS)** 으로 해결할 수 있다.

---

## 🛠️ 알고리즘 흐름
1. 임의의 노드(보통 1번)에서 BFS/DFS 실행  
   → 가장 먼 노드 `farthestNode`를 찾음.  
2. `farthestNode`에서 다시 BFS/DFS 실행  
   → 가장 먼 거리 = **트리의 지름**.  

---

## ⚠️ 예외 처리
- `n == 1` → 노드가 하나뿐이므로 지름은 `0`.  

---

## ⏱️ 시간 복잡도
- BFS/DFS 한 번 = `O(n)`  
- 두 번 실행 = `O(2n)` → `O(n)`  
- n = 10,000이므로 충분히 가능.

---

## ✅ 코드 (Java, BFS 사용)
```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, maxLen, startNode;
    static ArrayList<Edge>[] edge;

    static class Edge {
        int idx, cost;

        Edge(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        n = Integer.parseInt(br.readLine());

        if (n == 1) {
            bw.write("0\n");
            bw.flush();
            bw.close();
            br.close();
            return;
        }

        edge = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            edge[i] = new ArrayList<>();
        }

        for (int i = 1; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            edge[a].add(new Edge(b, c));
            edge[b].add(new Edge(a, c));
        }

        bfs(1);

        maxLen = 0;
        bfs(startNode);

        bw.write(maxLen + "\n");

        bw.flush();
        bw.close();
        br.close();
    }

    static void bfs(int start) {
        Queue<Edge> queue = new ArrayDeque<>();
        queue.offer(new Edge(start, 0));

        boolean[] visited = new boolean[n + 1];
        visited[start] = true;

        while (!queue.isEmpty()) {
            Edge now = queue.poll();

            if (now.cost > maxLen) {
                maxLen = now.cost;
                startNode = now.idx;
            }

            for (Edge next : edge[now.idx]) {
                if (!visited[next.idx]) {
                    visited[next.idx] = true;
                    queue.offer(new Edge(next.idx, now.cost + next.cost));
                }
            }
        }
    }
}
```