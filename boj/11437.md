# BOJ 11437 - LCA

## 📌 문제 링크
[https://www.acmicpc.net/problem/11437](https://www.acmicpc.net/problem/11437)

---

## 📖 문제 요약
- 루트가 1인 트리가 주어짐.
- 두 노드 `a`, `b`가 주어질 때, **가장 가까운 공통 조상(LCA)**을 구하는 문제.
- 트리의 크기: 최대 `50,000` 노드, 쿼리 최대 `10,000`.

---

## 💡 접근 방법
1. **트리 입력 받기**
   - 인접 리스트로 트리를 저장.

2. **부모와 깊이 계산**
   - DFS 또는 BFS를 통해 각 노드의 부모(`parent`)와 깊이(`depth`)를 기록.

3. **LCA 찾기**
   - 두 노드 `a`, `b`의 깊이가 다르면 → 더 깊은 쪽을 부모로 올려서 깊이 맞추기.
   - 깊이가 같아지면 → 동시에 부모로 올리며 처음 만나는 노드가 LCA.

---

## ⏱️ 시간 복잡도
- 전처리(DFS): `O(N)`
- 쿼리(LCA 탐색): `O(N)` 최악 (트리 깊이만큼)
- N=50,000, Q=10,000 → 충분히 통과 가능.

---

## 📝 풀이 코드 (Java)

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N, M;
    static ArrayList<Integer>[] tree;
    static int[] parent, depth;
    static boolean[] visited;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        tree = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) tree[i] = new ArrayList<>();

        for (int i = 0; i < N - 1; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            tree[a].add(b);
            tree[b].add(a);
        }

        parent = new int[N + 1];
        depth = new int[N + 1];
        visited = new boolean[N + 1];

        dfs(1, 0, 0);

        M = Integer.parseInt(br.readLine());
        for (int i = 0; i < M; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            bw.write(LCA(a, b) + "\n");
        }

        br.close();
        bw.flush();
        bw.close();
    }

    static void dfs(int node, int par, int d) {
        visited[node] = true;
        parent[node] = par;
        depth[node] = d;

        for (int next : tree[node]) {
            if (!visited[next]) dfs(next, node, d + 1);
        }
    }

    static int LCA(int a, int b) {
        // 깊이 맞추기
        while (depth[a] > depth[b]) a = parent[a];
        while (depth[b] > depth[a]) b = parent[b];

        // 같은 깊이에서 동시에 부모로 이동
        while (a != b) {
            a = parent[a];
            b = parent[b];
        }
        return a;
    }
}
```