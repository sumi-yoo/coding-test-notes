# BOJ 2110 - 공유기 설치

## 문제 링크
[https://www.acmicpc.net/problem/2110](https://www.acmicpc.net/problem/2110)

---

## 🧩 문제 요약
- N개의 집이 1차원 좌표에 있음.
- C개의 공유기를 설치할 때, **공유기 사이의 최소 거리**를 **최대로** 하고 싶음.
- 각 집에는 공유기를 하나만 설치 가능.

---

## ✅ 해결 전략

### 1. 집 좌표 정렬
- 설치 가능한 거리를 계산하려면 집 좌표를 오름차순으로 정렬해야 함.
- 정렬 후, 왼쪽에서부터 순차적으로 탐욕적(Greedy) 설치 진행.

### 2. 최소 거리(mid)를 이분 탐색
- 탐색 범위:
  - 최소 거리 `low = 1`
  - 최대 거리 `high = house[N-1] - house[0]`
- 반복:
  - 중간 거리 `mid = (low + high)/2`
  - `mid` 거리 이상으로 C개의 공유기 설치 가능하면 `low = mid + 1` (더 큰 거리 탐색)
  - 설치 불가하면 `high = mid - 1` (거리 줄이기)
- 최대 최소 거리를 `answer`에 저장
- 💡 **첫 집에 반드시 공유기를 설치**하는 이유:
  - 탐욕적 설치 전략으로 왼쪽에서부터 순차적으로 설치하며 최소 거리 조건을 유지하기 위해
  - 첫 집을 기준으로 다음 설치 가능 집을 판단하는 것이 가장 안전하고 단순

### 3. 설치 가능 여부 확인 함수
- 첫 집에 공유기 설치 후, `mid` 이상 떨어진 집에만 설치
- 설치한 공유기 수가 `C` 이상이면 가능

---

## 🧠 사용 알고리즘

이분 탐색 (Binary Search)

결정 함수(Decision Function) 활용 → 최소 거리를 최대화하는 구조

탐욕적(Greedy) 설치 전략으로 최소 거리 조건 만족

---

## 💻 코드

```java
import java.io.*;
import java.util.*;

public class Main {

    static int N, C;
    static int[] house;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        C = Integer.parseInt(st.nextToken());

        house = new int[N];
        for (int i = 0; i < N; i++) {
            house[i] = Integer.parseInt(br.readLine());
        }

        Arrays.sort(house);

        int answer = 1;
        int left = 1, right = house[N - 1] - house[0];

        while (left <= right) {
            int mid = (left + right) / 2;

            if (isValid(mid)) {
                answer = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        bw.write(answer + "\n");

        bw.flush();
        bw.close();
        br.close();
    }

    static boolean isValid(int dist) {
        int cur = house[0];
        int cnt = 1;

        for (int i = 1; i < N; i++) {
            if (house[i] - cur >= dist) {
                cnt++;
                cur = house[i];
            }
        }

        return cnt >= C;
    }
}
```