# BOJ 1916 - 최소비용 구하기

## 문제 링크
[https://www.acmicpc.net/problem/1916](https://www.acmicpc.net/problem/1916)

## 문제 설명
N개의 도시가 있고, 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다.  
각 버스는 비용이 존재하며, 출발 도시에서 도착 도시까지 가는 최소 비용을 구하는 문제.

- 도시 번호: 1번 ~ N번
- 버스의 개수 M
- 각 버스 정보: (출발 도시, 도착 도시, 비용)
- 시작 도시에서 도착 도시까지의 **최소 비용**을 출력

## 제약 조건
- N(1 ≤ N ≤ 1,000)
- M(1 ≤ M ≤ 100,000)
- C: 비용 (0 < C ≤ 100,000)

## 문제 풀이 아이디어
- 가중치가 있는 방향 그래프의 최단 경로 문제 → **다익스트라 알고리즘** 사용
- N 최대 1,000, M 최대 100,000 → 인접 리스트 + 우선순위 큐 사용 (O(M log N))
- 방문한 노드 중 이미 최소 비용이 확정된 경우는 건너뛴다.

## 알고리즘 절차
1. 인접 리스트(`List<Node>[]`)로 그래프 저장
2. `dist[]` 배열을 INF로 초기화
3. 시작 도시의 거리를 0으로 설정 후 우선순위 큐에 삽입
4. 큐에서 노드를 꺼내서 연결된 노드의 거리를 갱신
5. 최종적으로 도착 도시의 `dist` 값을 출력

## Java 코드
```java
import java.io.*;
import java.util.*;

public class Main {

    static final int INF = 1_000_000_000;
    static int N;
    static List<Node>[] graph;
    static class Node implements Comparable<Node> {
        int idx, cost;

        Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }


        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        int M = Integer.parseInt(br.readLine());

        graph = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            graph[a].add(new Node(b, c));
        }

        StringTokenizer st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken());
        int end = Integer.parseInt(st.nextToken());

        int[] distFromStart = dijkstra(start);
        bw.write(distFromStart[end] + " \n");

        bw.flush();
        bw.close();
        br.close();
    }

    static int[] dijkstra(int start) {
        int[] dist = new int[N + 1];
        Arrays.fill(dist, INF);
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            if (now.cost > dist[now.idx]) continue;

            for (Node next: graph[now.idx]) {
                int nextCost = next.cost + now.cost;
                if (nextCost < dist[next.idx]) {
                    dist[next.idx] = nextCost;
                    pq.offer(new Node(next.idx, nextCost));
                }
            }
        }

        return dist;
    }
}
```