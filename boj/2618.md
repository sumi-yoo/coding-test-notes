# BOJ 2618 - 경찰차

[🔗 문제 링크](https://www.acmicpc.net/problem/2618)

---

## 문제 해설
- `n × n` 크기의 도시, 1번 경찰차는 `(1,1)`에서 출발, 2번 경찰차는 `(n,n)`에서 출발.
- `w`개의 사건이 순서대로 발생하며, 각 경찰차는 사건을 해결하러 이동 가능.
- 한 사건은 반드시 한 경찰차가 처리해야 하며, 각 사건은 순서대로 처리.
- 두 경찰차가 협력하여 **총 이동 거리의 합을 최소화**하는 방법과,
  각 사건을 **어느 경찰차가 맡는지** 경로를 출력.

## 풀이 아이디어
1. **DP 정의**
   - `dp[a][b]` : 1번 경찰차가 `a`번째 사건을, 2번 경찰차가 `b`번째 사건을 처리했을 때의 최소 이동 거리.
   - 현재 처리해야 할 사건 번호 = `max(a, b) + 1`.
   - 사건 번호 `0`은 "아직 처리 안 함"을 의미하며, 1번 경찰차의 시작 위치 `(1,1)`과 2번 경찰차의 시작 위치 `(n,n)`에서 출발.

2. **점화식**
   - 현재 사건 번호 = `nextEvent`
   - 1번 경찰차가 처리할 경우:
     ```
     dp[a][b] = min(dp[a][b], dist(posA, event[nextEvent]) + dp[nextEvent][b])
     ```
   - 2번 경찰차가 처리할 경우:
     ```
     dp[a][b] = min(dp[a][b], dist(posB, event[nextEvent]) + dp[a][nextEvent])
     ```

3. **거리 계산**
   - `dist(p1, p2) = |x1 - x2| + |y1 - y2|` (맨해튼 거리)

4. **경로 복원**
   - `path[a][b]`에 다음 사건을 누가 처리했는지 저장(1번 경찰차 or 2번 경찰차).
   - DP 계산이 끝나면 `(0, 0)`부터 시작해 path를 따라가며 사건 배정 경로 출력.

## 시간 복잡도
- 사건 수 `w`에 대해 DP 테이블 크기는 `(w+1) × (w+1)`.
- 각 상태에서 O(1) 연산이므로 **O(w²)**.

## Java 코드
```java
import java.io.*;
import java.util.*;

public class Main {

    static int N, W;
    static Point[] events;
    static int[][] dp, choice;
    static BufferedWriter bw;

    static class Point {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        W = Integer.parseInt(br.readLine());

        events = new Point[W + 1];
        for (int i = 1; i <= W; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            events[i] = new Point(x, y);
        }

        dp = new int[W + 1][W + 1];
        for (int[] row : dp) Arrays.fill(row, -1);
        choice = new int[W + 1][W + 1];
        bw.write(solve(0, 0) + "\n");

        dfs(0, 0);

        bw.flush();
        bw.close();
        br.close();
    }

    static int solve(int a, int b) {
        int next = Math.max(a, b) + 1;
        if (next > W) return 0;

        if (dp[a][b] != -1) return dp[a][b];

        Point posA = (a == 0) ? new Point(1, 1) : events[a];
        Point posB = (b == 0) ? new Point(N, N) : events[b];

        int distA = getDist(posA, events[next]) + solve(next, b);
        int distB = getDist(posB, events[next]) + solve(a, next);

        if (distA <= distB) {
            dp[a][b] = distA;
            choice[a][b] = 1;
        } else {
            dp[a][b] = distB;
            choice[a][b] = 2;
        }

        return dp[a][b];
    }

    static int getDist(Point p1, Point p2) {
        return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
    }

    static void dfs(int a, int b) throws IOException {
        int next = Math.max(a, b) + 1;
        if (next > W) return;

        bw.write(choice[a][b] + "\n");
        if (choice[a][b] == 1) {
            dfs(next, b);
        } else {
            dfs(a, next);
        }
    }
}
```