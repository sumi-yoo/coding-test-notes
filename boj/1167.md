# BOJ 1167 - 트리의 지름

## 문제 링크
https://www.acmicpc.net/problem/1167

## 문제 요약
- 트리가 주어짐 (노드 번호 1~V)  
- 트리의 지름: 트리 내 모든 노드 쌍 중 가장 긴 거리  
- 각 간선에는 가중치(거리) 있음  
- 출력: 지름의 길이

## 접근 방법
1. 트리의 특징: 사이클 없음 → 두 노드 사이 경로는 유일
2. 트리 지름 구하는 방법:  
   - 임의의 노드에서 가장 먼 노드 A 찾기  
   - A에서 다시 가장 먼 노드 B까지 거리 → 트리 지름
3. DFS/BFS 둘 다 가능 → 여기서는 DFS 사용
4. 인접 리스트 + Edge 클래스 사용
5. visited 배열로 백트래킹

## 알고리즘 흐름
1. 입력으로 트리 구성 → ArrayList<Edge>[] edges  
2. 첫 번째 DFS: 루트 노드(1)에서 가장 먼 노드 farthestNode 찾기  
3. 두 번째 DFS: farthestNode에서 최대 거리 계산 → maxLen  
4. 출력

## 핵심 포인트
- 트리 지름 = 트리 내 모든 노드 쌍 중 최대 거리  
- 임의 노드에서 가장 먼 노드 = 지름의 끝점  
- 그 끝점에서 가장 먼 노드까지 거리 = 트리 지름  

## 전체 코드 (Java)
```java
import java.io.*;
import java.util.*;

public class Main {

    static int V, maxLen, startNode;
    static ArrayList<Edge>[] edges;
    static boolean[] visited;

    static class Edge {
        int idx, cost;

        Edge(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        V = Integer.parseInt(br.readLine());

        edges = new ArrayList[V + 1];
        visited = new boolean[V + 1];

        for (int i = 1; i <= V; i++) {
            edges[i] = new ArrayList<>();
        }

        for (int i = 1; i <= V; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int node = Integer.parseInt(st.nextToken());
            while (st.hasMoreTokens()) {
                int input = Integer.parseInt(st.nextToken());
                if (input == -1) break;
                int dis = Integer.parseInt(st.nextToken());

                edges[node].add(new Edge(input, dis));
            }
        }

        dfs(1, 0);

        maxLen = 0;
        visited = new boolean[V + 1];

        dfs(startNode, 0);

        bw.write(maxLen + "\n");

        bw.flush();
        bw.close();
        br.close();
    }

    static void dfs(int node, int dist) {
        visited[node] = true;
        if (dist > maxLen) {
            maxLen = dist;
            startNode = node;
        }

        for (Edge next : edges[node]) {
            if (!visited[next.idx]) {
                visited[next.idx] = true;
                dfs(next.idx, dist + next.cost);
            }
        }
    }
}
```