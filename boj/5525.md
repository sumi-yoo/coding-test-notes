# BOJ 5525 - IOIOI

## 문제 링크
[https://www.acmicpc.net/problem/5525](https://www.acmicpc.net/problem/5525)

---

## 문제 요약
- 정수 `N`, 문자열 길이 `M`, 문자열 `S`가 주어진다.
- 패턴 `Pn = I (OI)^N` 가 문자열 `S`에 몇 번 등장하는지 구하라.
- 겹치는 경우도 포함해야 한다.

---

## 단순한 접근
- 단순히 `S`의 모든 위치에서 길이 `2N+1` 만큼 잘라 비교하면  
  시간 복잡도 `O(N × M)` → 최악의 경우 약 10^12 연산 → 시간 초과.

---

## 핵심 아이디어
- 패턴은 `"IOI"` 블록이 `N`번 연속하는 형태.
- 따라서 문자열 `S`를 탐색하면서 `"IOI"` 블록이 몇 번 연속하는지 세면 된다.
- `"IOI"`가 연속으로 `N`번 나오면 패턴 하나 완성.
- 이때 **겹치는 패턴도 포함**되므로, 패턴을 찾을 때마다 `count--` 해서 마지막 `"IOI"`는 다음 검사에 재사용한다.

---

## 알고리즘 흐름
1. 문자열 `S`를 왼쪽부터 탐색.
2. `"IOI"` 패턴 발견 시 `count++`.
3. 만약 `count == N`이면:
   - 정답 `ans++`
   - `count--` (마지막 IOI는 유지)
4. `"IOI"`가 아니면 `count = 0` 초기화.
5. 문자열 끝까지 탐색 후 `ans` 출력.

---

## 전체 코드 (Java)
```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        int M = Integer.parseInt(br.readLine());
        String S = br.readLine();

        int ans = 0;
        int count = 0;

        for (int i = 1; i < M - 1; i++) {
            // "IOI" 패턴 발견
            if (S.charAt(i - 1) == 'I' && S.charAt(i) == 'O' && S.charAt(i + 1) == 'I') {
                count++;

                if (count == N) {
                    ans++;
                    count--; // 겹치는 패턴 처리
                }
                i++; // "OI"는 스킵
            } else {
                count = 0; // 연속성 깨짐
            }
        }

        System.out.println(ans);
    }
}
```